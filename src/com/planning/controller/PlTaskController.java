/*Generado por Disrupsoft*/
package com.planning.controller;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/

import com.planning.diagram.Edge;
import com.planning.diagram.Modelo;
import com.planning.diagram.Node;
import com.planning.entity.*;
import com.planning.exception.PlTaskException;
import com.planning.service.*;
import com.planning.util.ArregloCreator;
import com.planning.exception.OracleException;
import com.planning.util.Error;
import com.planning.util.MapeadorObjetos;
import com.planning.util.RestModelAndView;
import com.wordnik.swagger.annotations.Api;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.http.ResponseEntity;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Controller object for domain model class PlTask.
 *
 * @see PlTask
 */
@RestController(value = "Planning.PlTaskController")
@RequestMapping("/planTarea")
@Api(description = "Exposes APIs to work with PlTask resource.", value = "PlTaskController")
public class PlTaskController {
    
    private static final Logger LOGGER = LoggerFactory.getLogger(PlTaskController.class);
    
    @Autowired
    private PlTaskService plTaskService;
    
    @Autowired
    private PlanService planService;
    
    @Autowired
    private ChildTaskService childTaskService;
    
    @Autowired
    private TaskService taskService;
    
    @Autowired
    private PositionService positionService;
    
    @Autowired
    private AreaService areaService;
    
    @Autowired
    private GrupoRepository grupoRepository;
    
    @Autowired
    private ManagementService managementService;
    
    @Autowired
    private CriticalyLevelService levelService;
    
    @Autowired
    private DocumentService documentService;
    
    @Autowired
    private MapeadorObjetos mapeadorObjetos;
    
    private Set<Antecesora> antecesoras;
    
    private Set<Antecesora> sucesoras;
    
    @RequestMapping(value = "/listarTareasRelacionadas/{idTarea}/{idPlan}", method = {RequestMethod.POST, RequestMethod.GET})
    public ModelAndView listarTareasRelacionadas(@PathVariable Integer idTarea, @PathVariable Integer idPlan, ModelMap map) {
        antecesoras = new HashSet<>();
        sucesoras = new HashSet<>();
        Task task = taskService.findOne(idTarea);
        Plan plan = planService.findOne(idPlan);
        PlTask plTask = plTaskService.findByPlanAndTask(plan, task);
        List<ChildTask> childSucesoras = childTaskService.findByFromAndIsChild(plTask, true);
        List<ChildTask> childPredecesoras = childTaskService.findByToAndIsChild(plTask, true);
        childSucesoras.forEach((ChildTask hijo) -> {
            sucesoras.add(new Antecesora(hijo.getTo().getTask()));
        });
        for (ChildTask childTask : childPredecesoras) {
            Antecesora antecesora = new Antecesora(childTask.getFrom());
            if (!existeAntecesora(antecesora)) {
                antecesoras.add(antecesora);
            }
        }
        List<Document> documents = documentService.findByTaskId(task.getId());
        List<Grupo> grupoList = grupoRepository.findByTaskGrupo(task);
        List<Grupo> grupos = grupoRepository.findByPlan(plan);
        List<Task> tareasAgrupadas = grupos.parallelStream().map(grupo -> grupo.getTaskAgrupada()).collect(Collectors.toList());
        List<Antecesora> antecesorasAgrupadas = tareasAgrupadas.parallelStream().map(tarea -> new Antecesora(tarea)).collect(Collectors.toList());
        List<Antecesora> tasks = taskService.findAll().parallelStream().map(task1 -> new Antecesora(task1)).filter(task1 -> !sucesoras.contains(task1)).collect(Collectors.toList());
        List<Antecesora> noAgrupadas = tasks.parallelStream().filter(task1 -> !Objects.equals(task1.getId(), task.getId()) && !antecesorasAgrupadas.contains(task1) && task.getPosition().getArea().getManagement().equals(task1.getPosition().getArea().getManagement())).
                collect(Collectors.toList());
        List<Area> areas = areaService.findByManagementId(plTask.getTask().getPosition().getArea().getManagement().getId());
        List<Position> positions = positionService.findByAreaId(plTask.getTask().getPosition().getArea().getId());
        List<Antecesora> agrupadas = grupoList.parallelStream().map(grupo -> new Antecesora(grupo.getTaskAgrupada())).collect(Collectors.toList());
        map.put("antecesoras", antecesoras);
        map.put("sucesoras", sucesoras);
        map.put("agrupadas", agrupadas);
        map.put("noAgrupadas", noAgrupadas);
        map.put("todasTareas", tasks);
        map.put("tarea", ArregloCreator.cargarTarea(task, areas, positions, documents));
        return RestModelAndView.ok(map);
    }
    
    private boolean existeAntecesora(Antecesora antecesora) {
        if (antecesoras.isEmpty()) {
            return false;
        }
        for (Antecesora ant : antecesoras) {
            if (ant.getId().equals(antecesora.getId())) {
                return true;
            }
        }
        return false;
    }
    
    //    private void buscarAntecesorasRecursivo(PlTask to) {
//        antecesoras.add(new Antecesora(to));
//        List<ChildTask> childTasks = childTaskService.findByToAndIsChild(to, true);
//        if (childTasks.isEmpty()) {
//            return;
//        }
//        for (ChildTask childTask : childTasks) {
//            buscarAntecesorasRecursivo(childTask.getFrom());
//        }
//    }
    @RequestMapping(value = "/listarTareasPlan/{plan}", method = RequestMethod.POST)
    public ModelAndView createPlTask(@PathVariable Plan plan, @RequestParam Integer cargo, @RequestParam Integer gerencia, @RequestParam Integer direccion, @RequestParam Integer criticidad) {
        List<Task> taskList = new LinkedList<>();
        if (criticidad != null) {
            CriticalyLevel criticalyLevel = levelService.findOne(criticidad);
            if (cargo != null) {
                Position position = positionService.findOne(cargo);
                taskList = plTaskService.findByPlanAndTask_CriticalyLevelsContainsAndTask_Position(plan, criticalyLevel, position).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
            } else if (gerencia != null) {
                Area areaBd = areaService.findOne(gerencia);
                taskList = plTaskService.findByPlanAndTask_CriticalyLevelsContainsAndTask_Position_Area(plan, criticalyLevel, areaBd).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
            } else if (direccion != null) {
                Management management = managementService.findOne(direccion);
                taskList = plTaskService.findByPlanAndTask_CriticalyLevelsContainsAndTask_Position_Area_Management(plan, criticalyLevel, management).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
            } else {
                taskList = plTaskService.findByPlanAndTask_CriticalyLevelsContains(plan, criticalyLevel).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
            }
        } else if (cargo != null) {
            Position position = positionService.findOne(cargo);
            taskList = plTaskService.findByPlanAndTask_Position(plan, position).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
        } else if (gerencia != null) {
            Area areaBd = areaService.findOne(gerencia);
            taskList = plTaskService.findByPlanAndTask_Position_Area(plan, areaBd).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
        } else if (direccion != null) {
            Management management = managementService.findOne(direccion);
            taskList = plTaskService.findByPlanAndTask_Position_Area_Management(plan, management).parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
        } else {
            Set<PlTask> plTasks = new HashSet<>(plTaskService.findByPlan(plan));
            taskList = plTasks.parallelStream().map(plTask -> plTask.getTask()).collect(Collectors.toList());
        }
        return RestModelAndView.ok(tareasPlan(taskList));
    }
    
    @RequestMapping(value = "/insertarEliminarLink", method = RequestMethod.POST)
    public ModelAndView insertarEliminarLink(@RequestParam Integer from, @RequestParam Integer to, @RequestParam Integer planId, @RequestParam Boolean accion, ModelMap map) {
        Task taskFrom = taskService.findOne(from);
        Task taskTo = taskService.findOne(to);
        Plan plan = planService.findOne(planId);
        PlTask plTaskFrom = plTaskService.findByPlanAndTask(plan, taskFrom);
        PlTask plTaskTo = plTaskService.findByPlanAndTask(plan, taskTo);
        Optional<ChildTask> optional = childTaskService.findByFromAndTo(plTaskFrom, plTaskTo);
        if (accion) {
            if (!optional.isPresent()) {
                ChildTask childTask = new ChildTask();
                childTask.setFrom(plTaskFrom);
                childTask.setTo(plTaskTo);
                childTask.setIsChild(true);
                childTaskService.saveAndFlush(childTask);
                map.put("success", true);
                map.put("message", "Se creó el enlace entre la tarea '" + taskFrom.getName() + "' y '" + taskTo.getName() + "'");
            } else {
                map.put("success", false);
                map.put("message", "Ya existe la relación entre estas tareas.");
            }
        } else {
            if (optional.isPresent()) {
                ChildTask childTask = optional.get();
                childTaskService.delete(childTask);
                map.put("success", true);
                map.put("message", "Se eliminó el enlace entre la tarea '" + taskFrom.getName() + "' y '" + taskTo.getName() + "'");
            }
        }
        return RestModelAndView.ok(map);
    }
    
    @RequestMapping(value = "/eliminarTareaGrafico", method = RequestMethod.POST)
    public ModelAndView eliminarTareaGrafico(@RequestParam Integer tareaId, @RequestParam Integer planId, ModelMap map) {
        try {
            Task task = taskService.findOne(tareaId);
            Plan plan = planService.findOne(planId);
            if (plan.getDiagrama() != null) {
                Modelo modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
                ArrayList<Node> nodes = modelo.buscarNodo(tareaId);
                for (Node node : nodes) {
                    modelo.deleteNode(node);
                }
                ArrayList<Edge> edges = modelo.buscarLink(tareaId);
                for (Edge edge : edges) {
                    modelo.deleteEdge(edge);
                }
                String jsonModel = mapeadorObjetos.writeValueAsString(modelo);
                plan.setDiagrama(jsonModel);
                planService.saveAndFlush(plan);
            }
            PlTask plTask = plTaskService.findByPlanAndTask(plan, task);
            List<ChildTask> childTasks = childTaskService.findByFromOrTo(plTask, plTask);
            for (ChildTask childTask : childTasks) {
                childTaskService.delete(childTask);
            }
            plTaskService.delete(plTask);
            map.put("success", true);
            map.put("message", "Se eliminó la tarea: " + task.getName());
        } catch (Exception e) {
            if (e instanceof InvalidDataAccessApiUsageException) {
                map.put("success", false);
                map.put("message", "Esta tarea no se encuentra.");
            }
        }
        return RestModelAndView.ok(map);
    }
    
    private ModelMap tareasPlan(List<Task> tasks) {
        ModelMap map = new ModelMap();
        map.put("sEcho", "1");
        map.put("iTotalRecords", tasks.size());
        map.put("iTotalDisplayRecords", tasks.size());
        ModelMap[] modelMaps = new ModelMap[tasks.size()];
        int cont = tasks.size();
        for (int i = 0; i < cont; i++) {
            modelMaps[i] = ArregloCreator.crearTareaPlan(tasks.get(i));
        }
        map.put("aaData", modelMaps);
        return map;
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Error> tratarExcepcion(Exception e) {
        LOGGER.warn(e.getLocalizedMessage(), e);
        OracleException oe = new PlTaskException(e);
        return ResponseEntity.ok(oe.getError());
    }
}
