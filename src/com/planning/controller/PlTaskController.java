/*Generado por Disrupsoft*/
package com.planning.controller;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/

import com.planning.entity.*;
import com.planning.service.ChildTaskService;
import com.planning.service.PlTaskService;
import com.planning.service.PlanService;
import com.planning.service.TaskService;
import com.planning.util.OracleException;
import com.planning.util.RestModelAndView;
import com.wavemaker.tools.api.core.annotations.WMAccessVisibility;
import com.wavemaker.tools.api.core.models.AccessSpecifier;
import com.wordnik.swagger.annotations.Api;
import com.wordnik.swagger.annotations.ApiOperation;
import org.hibernate.exception.SQLGrammarException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.orm.jpa.JpaSystemException;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import javax.persistence.PersistenceException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Controller object for domain model class PlTask.
 *
 * @see PlTask
 */
@RestController(value = "Planning.PlTaskController")
@RequestMapping("/planTarea")
@Api(description = "Exposes APIs to work with PlTask resource.", value = "PlTaskController")
public class PlTaskController {
    
    private static final Logger LOGGER = LoggerFactory.getLogger(PlTaskController.class);
    
    @Autowired
    private PlTaskService plTaskService;
    
    @Autowired
    private PlanService planService;
    
    @Autowired
    private ChildTaskService childTaskService;
    
    @Autowired
    private TaskService taskService;
    
    private Set<Antecesora> antecesoras;
    
    private Set<Task> sucesoras;
    
    @RequestMapping(value = "/listarTareasRelacionadas/{idTarea}/{idPlan}", method = {RequestMethod.POST, RequestMethod.GET})
    public ModelAndView listarTareasRelacionadas(@PathVariable Integer idTarea, @PathVariable Integer idPlan, ModelMap map) {
        antecesoras = new HashSet<>();
        sucesoras = new HashSet<>();
        Task task = taskService.findOne(idTarea);
        Plan plan = planService.findOne(idPlan);
        PlTask plTask = plTaskService.findByPlanAndTask(plan, task);
        List<ChildTask> childSucesoras = childTaskService.findByFromAndIsChild(plTask, true);
        List<ChildTask> childPredecesoras = childTaskService.findByToAndIsChild(plTask, true);
        childSucesoras.forEach((ChildTask hijo) -> {
            sucesoras.add(hijo.getTo().getTask());
        });
        for (ChildTask childTask : childPredecesoras) {
            Antecesora antecesora = new Antecesora(childTask.getFrom());
            if (!existeAntecesora(antecesora))
                antecesoras.add(antecesora);
        }
        map.put("antecesoras", antecesoras);
        map.put("sucesoras", sucesoras);
        map.put("todasTareas", taskService.findAll());
        return RestModelAndView.ok(map);
    }
    
    
    private boolean existeAntecesora(Antecesora antecesora) {
        if (antecesoras.isEmpty())
            return false;
        for (Antecesora ant : antecesoras) {
            if (ant.getId().equals(antecesora.getId()))
                return true;
        }
        return false;
    }

//    private void buscarAntecesorasRecursivo(PlTask to) {
//        antecesoras.add(new Antecesora(to));
//        List<ChildTask> childTasks = childTaskService.findByToAndIsChild(to, true);
//        if (childTasks.isEmpty()) {
//            return;
//        }
//        for (ChildTask childTask : childTasks) {
//            buscarAntecesorasRecursivo(childTask.getFrom());
//        }
//    }
    
    @RequestMapping(value = "/", method = RequestMethod.GET)
    @ApiOperation(value = "Returns the list of PlTask instances.")
    public Page<PlTask> getPlTasks(Pageable pageable) {
        LOGGER.debug("Rendering PlTasks list");
        return plTaskService.findAll(pageable);
    }
    
    @RequestMapping(value = "/", method = RequestMethod.POST)
    @ApiOperation(value = "Creates a new PlTask instance.")
    public PlTask createPlTask(@RequestBody PlTask instance) {
        LOGGER.debug("Create PlTask with information: {}", instance);
        instance = plTaskService.saveAndFlush(instance);
        LOGGER.debug("Created PlTask with information: {}", instance);
        return instance;
    }
    
    /**
     * This setter method should only be used by unit tests
     *
     * @param service
     */
    protected void setPlTaskService(PlTaskService service) {
        this.plTaskService = service;
    }
    
    @RequestMapping(value = "/count", method = RequestMethod.GET)
    @WMAccessVisibility(value = AccessSpecifier.APP_ONLY)
    @ApiOperation(value = "Returns the total count of PlTask instances.")
    public Long countAllPlTasks() {
        LOGGER.debug("counting PlTasks");
        Long count = plTaskService.count();
        return count;
    }
    
    @ExceptionHandler(Exception.class)
    public ModelAndView tratarExcepcion(Exception e) {
        LOGGER.warn(e.getLocalizedMessage(), e);
        ModelMap modelMap = new ModelMap();
        if (e instanceof JpaSystemException) {
            JpaSystemException jse = (JpaSystemException) e;
            modelMap.put("error", tratarMensaje(jse.getMostSpecificCause()));
        } else if (e instanceof PersistenceException) {
            JpaSystemException exception = new JpaSystemException((PersistenceException) e);
            modelMap.put("error", tratarMensaje(exception.getMostSpecificCause()));
        } else if (e instanceof DataIntegrityViolationException) {
            DataIntegrityViolationException exception = (DataIntegrityViolationException) e;
            modelMap.put("error", tratarMensaje(exception.getMostSpecificCause()));
        } else if (e instanceof SQLGrammarException) {
            SQLGrammarException exception = (SQLGrammarException) e;
            modelMap.put("error", tratarMensaje(exception.getCause()));
        } else {
            OracleException oe = new OracleException(e);
            modelMap.put("error", oe.getMessage());
        }
        modelMap.put("success", false);
        return new RestModelAndView(modelMap);
    }
    
    private String tratarMensaje(Throwable e) {
        String message = e.getMessage();
        if (e.getMessage().contains("unq_facultad_0")) {
            return "Ya existen estas siglas.";
        } else if (e.getMessage().contains("unq_facultad_1")) {
            return "Ya existe este nombre de facultad.";
        } else if (e.getMessage().contains("UNIQUE_FROM_TO")) {
            return "No se puede insertar este v√≠nculo porque ya existe.";
        } else if (e.getMessage().contains("fk_departamento_id_facultad")) {
            return "No se puede eliminar esta facultad porque contiene departamentos.";
        }
        OracleException oe = new OracleException(message);
        return oe.getMensaje();
    }
    
}
