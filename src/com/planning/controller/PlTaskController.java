/*Generado por Disrupsoft*/
package com.planning.controller;

/*This is a Studio Managed File. DO NOT EDIT THIS FILE. Your changes may be reverted by Studio.*/
import com.planning.diagram.Edge;
import com.planning.diagram.Modelo;
import com.planning.diagram.ModeloAgrupado;
import com.planning.diagram.Node;
import com.planning.entity.*;
import com.planning.exception.PlTaskException;
import com.planning.notification.NotificationManager;
import com.planning.service.*;
import com.planning.util.ArregloCreator;
import com.planning.exception.OracleException;
import com.planning.util.Error;
import com.planning.util.MapeadorObjetos;
import com.planning.util.RestModelAndView;
import com.wordnik.swagger.annotations.Api;
import com.wordnik.swagger.annotations.ApiOperation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.InvalidDataAccessApiUsageException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import java.util.*;
import java.util.stream.Collectors;

import org.springframework.data.domain.Sort;

/**
 * Controller object for domain model class PlTask.
 *
 * @see PlTask
 */
@RestController(value = "Planning.PlTaskController")
@RequestMapping("/planTarea")
@Api(description = "Exposes APIs to work with PlTask resource.", value = "PlTaskController")
public class PlTaskController {

    private static final Logger LOGGER = LoggerFactory.getLogger(PlTaskController.class);

    @Autowired
    private PlTaskService planTareaService;

    @Autowired
    private PlanService planService;

    @Autowired
    private ChildTaskService childTaskService;

    @Autowired
    private TaskService taskService;

    @Autowired
    private PositionService positionService;

    @Autowired
    private AreaService areaService;

    @Autowired
    private GrupoRepository grupoRepository;

    @Autowired
    private ManagementService managementService;

    @Autowired
    private CriticalyLevelService levelService;

    @Autowired
    private DocumentService documentService;

    @Autowired
    private StatusTaskService statusTaskService;

    @Autowired
    private NotificacionService notificacionService;

    @Autowired
    private UserTokenService tokenService;

    @Autowired
    private ChannelService channelService;

    @Autowired
    private MapeadorObjetos mapeadorObjetos;

    private Set<Antecesora> antecesoras;

    private Set<Antecesora> sucesoras;

    @RequestMapping(value = "/listarTareasRelacionadas/{tareaId}", method = {RequestMethod.POST, RequestMethod.GET})
    public ModelAndView listarTareasRelacionadas(@PathVariable("tareaId") Integer tareaId, ModelMap map) {
        antecesoras = new HashSet<>();
        sucesoras = new HashSet<>();
        PlTask plTask = planTareaService.findOne(tareaId);
        Plan plan = plTask.getPlan();
        List<ChildTask> childSucesoras = childTaskService.findByFromAndIsChild(plTask.getId(), true);
        List<ChildTask> childPredecesoras = childTaskService.findByToAndIsChild(plTask.getId(), true);
        childSucesoras.forEach((ChildTask hijo) -> {
            sucesoras.add(new Antecesora(planTareaService.findOne(hijo.getTo())));
        });
        for (ChildTask childTask : childPredecesoras) {
            Antecesora antecesora = new Antecesora(planTareaService.findOne(childTask.getFrom()));
            if (!existeAntecesora(antecesora)) {
                antecesoras.add(antecesora);
            }
        }
        List<Document> documents = new ArrayList<>(plTask.getDocuments());
        List<Grupo> grupoList = grupoRepository.findByTaskGrupo(plTask);
        List<Grupo> grupos = grupoRepository.findByPlan(plan);
        List<PlTask> tareasAgrupadas = grupos.parallelStream().map(grupo -> grupo.getTaskAgrupada()).collect(Collectors.toList());
        List<Antecesora> antecesorasAgrupadas = tareasAgrupadas.parallelStream().map(tarea -> new Antecesora(tarea)).collect(Collectors.toList());
        List<PlTask> tareasPlan = planTareaService.findByPlan(plan);
        List<Antecesora> todasTareasPlan = tareasPlan.parallelStream().map(task1 -> new Antecesora(task1)).filter(task1 -> !sucesoras.contains(task1) && !Objects.equals(plTask.getId(), task1.getId())).collect(Collectors.toList());
        List<Antecesora> noAgrupadas = todasTareasPlan.parallelStream().filter(task1 -> !Objects.equals(task1.getId(), plTask.getId()) && !antecesorasAgrupadas.contains(task1)
                && plTask.getPosition().getArea().getManagement().equals(task1.getPosition().getArea().getManagement())).collect(Collectors.toList());
        List<Area> areas = areaService.findByManagementId(plTask.getPosition().getArea().getManagement().getId());
        List<Position> positions = positionService.findByAreaId(plTask.getPosition().getArea().getId());
        List<Antecesora> agrupadas = grupoList.parallelStream().map(grupo -> new Antecesora(grupo.getTaskAgrupada())).collect(Collectors.toList());
        map.put("antecesoras", antecesoras);
        map.put("sucesoras", sucesoras);
        map.put("agrupadas", agrupadas);
        map.put("noAgrupadas", noAgrupadas);
        map.put("todasTareas", todasTareasPlan);
        map.put("tarea", ArregloCreator.cargarTarea(plTask, areas, positions, documents));
        return RestModelAndView.ok(map);
    }

    private boolean existeAntecesora(Antecesora antecesora) {
        if (antecesoras.isEmpty()) {
            return false;
        }
        for (Antecesora ant : antecesoras) {
            if (ant.getId().equals(antecesora.getId())) {
                return true;
            }
        }
        return false;
    }

    @RequestMapping(value = "/listarTareasPlan/{plan}", method = RequestMethod.POST)
    public ModelAndView createPlTask(@PathVariable Plan plan, @RequestParam Integer cargo, @RequestParam Integer gerencia, @RequestParam Integer direccion, @RequestParam Integer criticidad) {
        List<PlTask> taskList = new LinkedList<>();
        if (criticidad != null) {
            CriticalyLevel criticalyLevel = levelService.findOne(criticidad);
            if (cargo != null) {
                Position position = positionService.findOne(cargo);
                taskList = planTareaService.findByPlanAndCriticalyLevelsContainsAndPosition(plan, criticalyLevel, position);
            } else if (gerencia != null) {
                Area areaBd = areaService.findOne(gerencia);
                taskList = planTareaService.findByPlanAndCriticalyLevelsContainsAndPosition_Area(plan, criticalyLevel, areaBd);
            } else if (direccion != null) {
                Management management = managementService.findOne(direccion);
                taskList = planTareaService.findByPlanAndCriticalyLevelsContainsAndPosition_Area_Management(plan, criticalyLevel, management);
            } else {
                taskList = planTareaService.findByPlanAndCriticalyLevelsContains(plan, criticalyLevel);
            }
        } else if (cargo != null) {
            Position position = positionService.findOne(cargo);
            taskList = planTareaService.findByPlanAndPosition(plan, position);
        } else if (gerencia != null) {
            Area areaBd = areaService.findOne(gerencia);
            taskList = planTareaService.findByPlanAndPosition_Area(plan, areaBd);
        } else if (direccion != null) {
            Management management = managementService.findOne(direccion);
            taskList = planTareaService.findByPlanAndPosition_Area_Management(plan, management);
        } else {
            Set<PlTask> plTasks = new HashSet<>(planTareaService.findByPlan(plan));
            taskList = new LinkedList<>(plTasks);
        }
        return RestModelAndView.ok(tareasPlan(taskList));
    }

    @RequestMapping(value = "/insertarEliminarLink", method = RequestMethod.POST)
    public ModelAndView insertarEliminarLink(@RequestParam Integer from, @RequestParam Integer to, @RequestParam Integer planId, @RequestParam Boolean accion, ModelMap map) {
        Optional<ChildTask> optional = childTaskService.findByFromAndTo(from, to);
        if (accion) {
            if (!optional.isPresent()) {
                PlTask taskFrom = planTareaService.findOne(from);
                if (taskFrom == null) {
                    map.put("success", false);
                    map.put("error", "No existe la tarea inicial que desea hacer el enlace.");
                    return RestModelAndView.ok(map);
                }
                PlTask taskTo = planTareaService.findOne(to);
                if (taskTo == null) {
                    map.put("success", false);
                    map.put("error", "No existe la tarea final a la que desea hacer el enlace.");
                    return RestModelAndView.ok(map);
                }
                Plan plan = taskFrom.getPlan();
                ChildTask childTask = new ChildTask();
                childTask.setFrom(from);
                childTask.setTo(to);
                childTask.setIsChild(true);
                childTaskService.saveAndFlush(childTask);
                if (plan.getDiagrama() != null && !plan.getDiagrama().isEmpty()) {
                    Modelo modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
                    modelo.addEdge(new Edge("" + from, "" + to));
                    if (modelo.isModificado()) {
                        plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
                        planService.saveAndFlush(plan);
                    }
                }
                map.put("success", true);
                map.put("message", "Se cre√≥ el enlace entre la tarea '" + taskFrom.getName() + "' y '" + taskTo.getName() + "'");
            } else {
                map.put("success", false);
                map.put("duplicado", true);
                return RestModelAndView.ok(map);
            }
        } else {
            if (optional.isPresent()) {
                PlTask taskFrom = planTareaService.findOne(from);
                PlTask taskTo = planTareaService.findOne(to);
                Plan plan = taskFrom.getPlan();
                ChildTask childTask = optional.get();
                childTaskService.delete(childTask);
                if (plan.getDiagrama() != null && !plan.getDiagrama().isEmpty()) {
                    Modelo modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
                    modelo.deleteEdge(new Edge("" + from, "" + to));
                    if (modelo.isModificado()) {
                        plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
                        planService.saveAndFlush(plan);
                    }
                }
                map.put("success", true);
                map.put("message", "Se elimin√≥ el enlace entre la tarea '" + taskFrom.getName() + "' y '" + taskTo.getName() + "'");
            }
        }
        return RestModelAndView.ok(map);
    }

    @RequestMapping(value = "/eliminarTareaGrafico", method = RequestMethod.POST)
    public ModelAndView eliminarTareaGrafico(@RequestParam Integer tareaId, @RequestParam Integer planId, ModelMap map) {
        try {
            PlTask plTask = planTareaService.findOne(tareaId);
            Plan plan = planService.findOne(planId);
            if (plan.getDiagrama() != null) {
                Modelo modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
                ArrayList<Node> nodes = modelo.buscarNodo(tareaId);
                for (Node node : nodes) {
                    modelo.deleteNode(node);
                }
                ArrayList<Edge> edges = modelo.buscarLink(tareaId);
                for (Edge edge : edges) {
                    modelo.deleteEdge(edge);
                }
                String jsonModel = mapeadorObjetos.writeValueAsString(modelo);
                plan.setDiagrama(jsonModel);
                planService.saveAndFlush(plan);
            }
            List<ChildTask> childTasks = childTaskService.findByFromOrTo(plTask.getId(), plTask.getId());
            for (ChildTask childTask : childTasks) {
                childTaskService.delete(childTask);
            }
            planTareaService.delete(plTask);
            map.put("success", true);
            map.put("message", "Se elimin√≥ la tarea: " + plTask.getName());
        } catch (Exception e) {
            if (e instanceof InvalidDataAccessApiUsageException) {
                map.put("success", false);
                map.put("message", "Esta tarea no se encuentra.");
            }
        }
        return RestModelAndView.ok(map);
    }

    @RequestMapping(value = "/salvarTareaPlan/{planId}/{tareaId}", method = RequestMethod.PUT)
    public ModelAndView salvarTareaPlan(@RequestBody PlTask planTarea, @PathVariable("planId") Plan plan, @PathVariable("tareaId") Task task, ModelMap map) {
        if (planTarea.getId() == null) {
            boolean existeDiagrama = plan.getDiagrama() != null && !plan.getDiagrama().isEmpty();
            ArrayList<CriticalyLevel> criticalyLevels = new ArrayList<>();
            planTarea.getCriticalyLevels().forEach(criticalyLevel -> {
                criticalyLevels.add(levelService.findOne(criticalyLevel.getId()));
            });
            planTarea.getCriticalyLevels().clear();
            planTarea.getCriticalyLevels().addAll(criticalyLevels);
            if (planTarea.isTranversal()) {
                if (!planTarea.validarTranversal()) {
                    map.put("success", false);
                    map.put("error", "Los niveles de alerta deben ser consecutivos");
                    return RestModelAndView.ok(map);
                }
            }
            if (!planTarea.isIsrecurrent()) {
                planTarea.setTiempoRecurrencia(0);
            }
            Position position = positionService.findOne(planTarea.getPosition().getId());
            Management management = position.getArea().getManagement();
            planTarea.setPosition(position);
            planTarea.setName(task.getName());
            planTarea.setPlan(plan);
            Optional<StatusTask> optional = statusTaskService.findByName("Inactiva");
            if (!plan.isEjecucion()) {
                if (optional.isPresent()) {
                    planTarea.setStatusTask(optional.get());
                }
                List<Area> areas = areaService.findByManagementId(position.getArea().getManagement().getId());
                List<Position> positions = positionService.findByAreaId(position.getArea().getId());
                List<Document> documents = new ArrayList<>(planTarea.getDocuments());
                map.put("tarea", ArregloCreator.cargarTarea(planTarea, areas, positions, documents));
            } else {
                map.put("success", false);
                map.put("error", "No se puede importar la tarea porque este plan est√° en ejecuci√≥n.");
                return new RestModelAndView(map);
            }

            Modelo modelo = null;
            planTareaService.saveAndFlush(planTarea);
            if (existeDiagrama) {
                modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
                if (modelo == null) {
                    modelo = new Modelo();
                }
                modelo.addNode(new Node(planTarea));
                Node node = modelo.buscarSider("sd" + management.getId());
                if (node == null) {
                    node = new Node();
                    node.setKey("sd" + management.getId());
                    node.setNombre(management.getName());
                    node.setCategory("Row Sider");
                    node.setPeso(management.getOrder());
                    node.setRow(management.getOrder());
                    modelo.addSider(node);
                    List<CriticalyLevel> levels = levelService.findAll(new Sort(Sort.Direction.ASC, "order"));
                    int i = 0;
                    for (CriticalyLevel level : levels) {
                        String celda = "Celda(" + management.getId() + "," + level.getId() + ")";
                        Node newNodeGrupo = new Node();
                        newNodeGrupo.setKey(celda);
                        newNodeGrupo.setNombre(celda);
                        newNodeGrupo.setCol(i + 2);
                        newNodeGrupo.setColor(level.getColor() + "1e");
                        newNodeGrupo.setRow(node.getRow());
                        newNodeGrupo.setEsGrupo(true);
                        Node newNodeInvisible = new Node();
                        newNodeInvisible.setKey(generateUuid());
                        newNodeInvisible.setGroup(celda);
                        newNodeInvisible.setColor("white");
                        newNodeInvisible.setSize("3 3");
                        newNodeInvisible.setNombre("");
                        modelo.addNode(newNodeGrupo);
                        modelo.addNode(newNodeInvisible);
                        i++;
                    }
                }
            }
            if (modelo != null && modelo.isModificado()) {
                plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
                planService.saveAndFlush(plan);
            }
            map.put("success", true);
            map.put("message", "La operaci√≥n se realiz√≥ correctamente");
            map.put("tarea", task);
            return RestModelAndView.ok(map);
        } else {
            return editarTareaPlan(planTarea, plan, map);
        }
    }

    private String generateUuid() {
        UUID uuid = UUID.randomUUID();
        return uuid.toString();
    }

    private ModelAndView editarTareaPlan(PlTask tarea, Plan plan, ModelMap map) {
        List<Tarea> sucesorasNuevas = tarea.getRelacionadas();
        Set<CriticalyLevel> criticalyLevels = tarea.getCriticalyLevels();
        Set<CriticalyLevel> criticalyLevelsNew = new TreeSet<>();
        List<Tarea> agrupadas = tarea.getAgrupadas();
        PlTask plTaskBd = planTareaService.findOne(tarea.getId());
        boolean tranversal = false, eraTranversal = false;
        boolean existeDiagrama = plan.getDiagrama() != null && !plan.getDiagrama().isEmpty();
        boolean existeAgrupado = plan.getModeloAgrupado() != null && !plan.getModeloAgrupado().isEmpty();
        List<Grupo> grupos = grupoRepository.findByPlanAndTaskGrupo(plan, plTaskBd);
        List<PlTask> agrupadasOld = grupos.parallelStream().map(grupo -> grupo.getTaskAgrupada()).collect(Collectors.toList());
        if (!agrupadasOld.isEmpty()) {
            grupoRepository.deleteByTaskGrupo(plTaskBd);
            plTaskBd.setGrupos(new ArrayList<>());
        }
        Position position = positionService.findOne(tarea.getPosition().getId());
        for (Tarea taskAgrupada : agrupadas) {
            Grupo grupo = new Grupo(plTaskBd.getId(), taskAgrupada.getId(), plan.getId());
            grupoRepository.save(grupo);
        }
        if (!agrupadas.isEmpty()) {
            grupoRepository.flush();
            HashSet<PlTask> tasks = buscarTareasDiferentes(agrupadas, agrupadasOld);
            if (!tasks.isEmpty() && existeDiagrama) {
                desagruparTareas(plan, tasks);
            }
            if (existeDiagrama) {
                eliminarTareasModelo(plan, agrupadas);
            }
        }
        if (agrupadas.isEmpty() && !agrupadasOld.isEmpty()) {
            HashSet<PlTask> tasks = buscarTareasDiferentes(agrupadas, agrupadasOld);
            if (!tasks.isEmpty() && existeDiagrama) {
                desagruparTareas(plan, tasks);
            }
        }
        if (tarea.isTranversal() != tarea.isTranversal()) {
            if (tarea.getCriticalyLevels().size() > 1 && criticalyLevels.size() <= 1) {
                eraTranversal = true;
            }
        }
        for (CriticalyLevel level : criticalyLevels) {
            criticalyLevelsNew.add(levelService.findOne(level.getId()));
        }
        final Set<Channel> channels = new HashSet<>();
        tarea.getChannels().forEach(channel -> {
            channels.add(channelService.findOne(channel.getId()));
        });
        tarea.setCriticalyLevels(criticalyLevelsNew);
        if (tarea.isTranversal()) {
            if (!tarea.validarTranversal()) {
                map.put("success", false);
                map.put("error", "Los niveles de alerta deben ser consecutivos");
                return RestModelAndView.ok(map);
            }
            tranversal = true;
        }
        StatusTask statusTask = statusTaskService.findOne(tarea.getStatusTask().getId());
        plTaskBd.clonarDatos(tarea);
        plTaskBd.setPosition(position);
        plTaskBd.setStatusTask(statusTask);
        plTaskBd.setCriticalyLevels(criticalyLevelsNew);
        plTaskBd.setChannels(channels);
        planTareaService.saveAndFlush(plTaskBd);
        if (statusTask.getName().compareTo("Ejecutada") == 0) {
            List<ChildTask> childTaskList = childTaskService.findByFrom(plTaskBd.getId());
            List<PlTask> taskList = childTaskList.parallelStream().map(childTask -> planTareaService.findOne(childTask.getFrom())).collect(Collectors.toList());
            cambiarSucesoras(taskList);
            List<UserToken> tokens = tokenService.findByUserPosition(position);
            List<String> playerIds = tokens.parallelStream().filter(userToken -> userToken.getPlayerId() != null && !userToken.getPlayerId().isEmpty()).map(UserToken::getPlayerId).collect(Collectors.toList());
            Notificacion notificacion = new Notificacion();
            notificacion.setFecha(new Date());
            notificacion.setPosition(position);
            notificacion.setDescription("La tarea \"" + plTaskBd.getName() + "\" ha cambiado de estado a " + statusTask.getName());
            notificacion.setTitle("Cambio de estado de tarea.");
            notificacionService.save(notificacion);
            boolean b = enviarNotificacion(notificacion, playerIds);
            LOGGER.debug(b + "");
        }
        Modelo modelo = null;
        boolean insertado = false;
        if (existeDiagrama) {
            modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
            ejecutarExistenciaModelo(plan, plTaskBd, tarea.getPosition(), criticalyLevels, modelo, tranversal, existeAgrupado, eraTranversal);
        }
        List<ChildTask> childs = childTaskService.findByFromAndIsChild(plTaskBd.getId(), true);
        if (sucesorasNuevas.size() < childs.size()) {
            for (ChildTask child : childs) {
                childTaskService.deleteById(child.getId());
            }
        }
        ArrayList<String> errores = new ArrayList<>();
        for (Tarea sucesora : sucesorasNuevas) {
            PlTask plTaskSucesora = planTareaService.findOne(sucesora.getId());
            ChildTask childTask = new ChildTask();
            childTask.setFrom(plTaskBd.getId());
            childTask.setTo(plTaskSucesora.getId());
            childTask.setIsChild(true);
            if (modelo != null) {
                modelo.addEdge(new Edge("" + childTask.getFrom(), "" + childTask.getTo()));
                modelo.addNode(new Node(plTaskBd));
            }
            try {
                if (!plTaskSucesora.getId().equals(plTaskBd.getId()) && childTask.isValid()) {
                    childTaskService.saveAndFlush(childTask);
                    insertado = true;
                }
            } catch (Exception e) {
                LOGGER.debug("Ya existe la relacion: {}", childTask);
                OracleException exception = new OracleException(e);
                errores.add("<li>" + exception.getMensaje() + "</li>");
            }
        }
        if (modelo != null && modelo.isModificado() && insertado) {
            plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
            planService.saveAndFlush(plan);
        }
        map.put("success", true);
        map.put("message", "La operaci√≥n se realiz√≥ correctamente");
        map.put("tarea", plTaskBd);
        return RestModelAndView.ok(map);
    }

    private void desagruparTareas(Plan plan, HashSet<PlTask> tasks) {
        if (plan.getDiagrama() != null && !plan.getDiagrama().isEmpty()) {
            ModeloAgrupado modeloAgrupado = null;
            Modelo modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
            if (plan.getModeloAgrupado() != null && !plan.getModeloAgrupado().isEmpty()) {
                modeloAgrupado = mapeadorObjetos.readValue(plan.getModeloAgrupado(), ModeloAgrupado.class);
            }
            if (modeloAgrupado != null) {
                for (PlTask task : tasks) {
                    ArrayList<Node> nodes = modeloAgrupado.buscarNodo(task.getId());
                    if (!nodes.isEmpty()) {
                        for (Node node : nodes) {
                            modelo.addNode(node);
                            modeloAgrupado.eliminarNode(node);
                        }
                    }
                    ArrayList<Edge> edges = modeloAgrupado.buscarLink(task.getId());
                    if (!edges.isEmpty()) {
                        for (Edge edge : edges) {
                            modelo.addEdge(edge);
                            modeloAgrupado.eliminarEdge(edge);
                        }
                    }
                }
                String modeloNew = mapeadorObjetos.writeValueAsString(modelo);
                String modeloAgrupadoNew = mapeadorObjetos.writeValueAsString(modeloAgrupado);
                plan.setDiagrama(modeloNew);
                plan.setModeloAgrupado(modeloAgrupadoNew);
                planService.saveAndFlush(plan);
            } else {
                for (PlTask plTask : tasks) {
                    modelo.addNode(new Node(plTask));
                }
                if (modelo.isModificado()) {
                    String modeloNew = mapeadorObjetos.writeValueAsString(modelo);
                    plan.setDiagrama(modeloNew);
                    planService.saveAndFlush(plan);
                }
            }
        }
    }

    private HashSet<PlTask> buscarTareasDiferentes(List<Tarea> agrupadasNew, List<PlTask> agrupadasBd) {
        HashSet<PlTask> tasks = new HashSet<>();
        if (!agrupadasBd.isEmpty() && agrupadasNew.isEmpty()) {
            tasks.addAll(agrupadasBd);
            return tasks;
        }
        for (PlTask task : agrupadasBd) {
            Set<Tarea> elementos = agrupadasNew.parallelStream().filter(tarea -> Objects.equals(tarea.getId(), task.getId())).collect(Collectors.toSet());
            if (elementos.isEmpty()) {
                tasks.add(task);
            }
        }
        return tasks;
    }

    private void ejecutarExistenciaModelo(Plan plan, PlTask tarea, Position position, Set<CriticalyLevel> criticalyLevels, Modelo modelo, boolean tranversal, boolean existeAgrupado, boolean eraTranversal) {
        if (tranversal) {
            TreeSet<CriticalyLevel> levels = new TreeSet<>(tarea.getCriticalyLevels());
            int colSpan = levels.last().getOrder() - levels.first().getOrder() + 1;
            ArrayList<Node> nodes = modelo.buscarNodo(tarea.getId());
            ModeloAgrupado modeloAgrupado = null;
            if (existeAgrupado) {
                modeloAgrupado = mapeadorObjetos.readValue(plan.getModeloAgrupado(), ModeloAgrupado.class);
            } else {
                modeloAgrupado = new ModeloAgrupado();
            }
            int i = 0;
            Node nodeTranversal = null;
            int tam = colSpan != 0 ? 400 * colSpan : 0;
            for (Node node : nodes) {
                if (i == 0) {
                    int columna = 1 + levels.first().getOrder();
                    Node sider = modelo.buscarSider("sd" + position.getArea().getManagement().getId());
                    String grupo = criticalyLevels.stream().map(level -> "" + level.getId()).collect(Collectors.joining("-"));
                    grupo = "tv" + sider.getRow() + "-" + grupo;
                    Node nodoGrupo = modelo.buscarNodo(grupo);
                    if (nodoGrupo == null) {
                        nodoGrupo = new Node();
                        nodoGrupo.setKey(grupo);
                        nodoGrupo.setNombre("");
                        nodoGrupo.setColor("transparent");
                        nodoGrupo.setCol(columna);
                        nodoGrupo.setColSpan(colSpan);
                        nodoGrupo.setRow(sider.getRow());
                        nodoGrupo.setEsGrupo(true);
                        Node invisible = new Node();
                        UUID uuid = UUID.randomUUID();
                        invisible.setKey(uuid.toString());
                        invisible.setNombre("");
                        invisible.setSize("0 200");
                        invisible.setColor("transparent");
                        invisible.setGroup(grupo);
                        modelo.addNode(nodoGrupo);
                        modelo.addNode(invisible);
                    }
                    nodeTranversal = new Node(node);
                    nodeTranversal.setGroup(grupo);
                }
                modeloAgrupado.addNode(node);
                modelo.deleteNode(node);
                i++;
            }
            if (i != 0) {
                nodeTranversal.setSize((tam + 200) + " 130");
                modelo.addNode(nodeTranversal);
                List<Edge> edges = modelo.buscarEdges(nodeTranversal);
                for (Edge edge : edges) {
                    edge.setPoints(new ArrayList<>());
                }
            }
            plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
            plan.setModeloAgrupado(mapeadorObjetos.writeValueAsString(modeloAgrupado));
            planService.saveAndFlush(plan);
        }
        if (eraTranversal) {
            ejecutarCambioANormal(plan, tarea, position, criticalyLevels, modelo);
        }
    }

    private void ejecutarCambioANormal(Plan plan, PlTask tarea, Position position, Set<CriticalyLevel> criticalyLevels, Modelo modelo) {
        ModeloAgrupado modeloAgrupado = new ModeloAgrupado();
        if (plan.getModeloAgrupado() != null && !plan.getModeloAgrupado().isEmpty()) {
            modeloAgrupado = mapeadorObjetos.readValue(plan.getModeloAgrupado(), ModeloAgrupado.class);
        }
        Node nodoTranversalOld = modelo.buscarNodo("" + tarea.getId());
        if (nodoTranversalOld != null) {
            modelo.deleteNode(nodoTranversalOld);
            boolean vacio = modelo.estaVacio(nodoTranversalOld.getGroup());
            if (vacio) {
                List<Node> invisibleNodesGrupo = modelo.getInvisibleNodesGrupo();
                invisibleNodesGrupo.forEach(modelo::deleteNode);
                Node nodoGrupo = modelo.buscarNodoGrupo(nodoTranversalOld.getGroup());
                modelo.deleteNode(nodoGrupo);
            }
        }
        ArrayList<Node> nodes = modeloAgrupado.buscarNodo(tarea.getId());
        if (!nodes.isEmpty()) {
            for (Node node : nodes) {
                modelo.addNode(node);
                modeloAgrupado.eliminarNode(node);
                List<Edge> edges = modelo.buscarEdges(node);
                for (Edge edge : edges) {
                    edge.setPoints(new ArrayList<>());
                }
            }
        } else {
            ArrayList<Node> nodos = modelo.buscarNodo(tarea.getId());
            for (Node node : nodos) {
                modelo.deleteNode(node);
            }
            Node node = new Node();
            node.setKey("" + tarea.getId());
            node.setNombre(tarea.getName());
            node.setColor("#ffebee");
            for (CriticalyLevel level : criticalyLevels) {
                node.setColorBorde(level.getColor());
                node.setGroup("Celda(" + position.getArea().getManagement().getId() + "," + level.getId() + ")");
                break;
            }
            node.setTareaId(tarea.getId());
            node.setProducto(tarea.getProduct());
            node.setCargo(position.getName());
            node.setCategory("");
            node.setPartida(tarea.isStart());
            modelo.addNode(node);
        }
        plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
        plan.setModeloAgrupado(mapeadorObjetos.writeValueAsString(modeloAgrupado));
        planService.saveAndFlush(plan);
    }

    private void cambiarSucesoras(List<PlTask> sucesoras) {
        StatusTask statusTask = statusTaskService.findByName("Disponible").get();
        for (PlTask task : sucesoras) {
            task.setStatusTask(statusTask);
            planTareaService.save(task);
            Position position = task.getPosition();
            List<UserToken> tokens = tokenService.findByUserPosition(position);
            List<String> playerIds = tokens.parallelStream().filter(userToken -> userToken.getPlayerId() != null && !userToken.getPlayerId().isEmpty()).map(UserToken::getPlayerId).collect(Collectors.toList());
            Notificacion notificacion = new Notificacion();
            notificacion.setFecha(new Date());
            notificacion.setPosition(position);
            notificacion.setDescription("La tarea \"" + task.getName() + "\" ha cambiado de estado a " + statusTask.getName());
            notificacion.setTitle("Nueva tarea disponible.");
            notificacionService.save(notificacion);
            boolean b = enviarNotificacion(notificacion, playerIds);
            LOGGER.debug(b + "");
        }
        taskService.flush();
    }

    private void eliminarTareasModelo(Plan plan, List<Tarea> agrupadas) {
        if (plan.getDiagrama() != null && !plan.getDiagrama().isEmpty()) {
            Modelo modelo = mapeadorObjetos.readValue(plan.getDiagrama(), Modelo.class);
            String agrupado = plan.getModeloAgrupado();
            agrupado = agrupado == null ? "" : agrupado;
            ModeloAgrupado modeloAgrupado = mapeadorObjetos.readValue(agrupado, ModeloAgrupado.class);
            if (modelo != null) {
                if (modeloAgrupado == null) {
                    modeloAgrupado = new ModeloAgrupado();
                }
                ArrayList<Node> nodeDataArray = modelo.getNodeDataArray();
                ArrayList<Edge> linkDataArray = modelo.getLinkDataArray();
                for (Tarea tarea : agrupadas) {
                    List<Node> elementos = nodeDataArray.parallelStream().filter(node -> node.getTareaId() != null && node.getTareaId().equals(tarea.getId())).collect(Collectors.toList());
                    List<Edge> edges = linkDataArray.parallelStream().filter(edge -> edge.getFrom().compareToIgnoreCase("" + tarea.getId()) == 0 || edge.getTo().compareToIgnoreCase("" + tarea.getId()) == 0).collect(Collectors.toList());
                    for (Node node : elementos) {
                        modeloAgrupado.addNode(node);
                        nodeDataArray.remove(node);
                    }
                    for (Edge edge : edges) {
                        modeloAgrupado.addLink(edge);
                        linkDataArray.remove(edge);
                    }
                }
                modelo.setLinkDataArray(linkDataArray);
                modelo.setNodeDataArray(nodeDataArray);
                String diagrama = mapeadorObjetos.writeValueAsString(modelo);
                String diagramaAgrupado = mapeadorObjetos.writeValueAsString(modeloAgrupado);
                plan.setDiagrama(diagrama);
                plan.setModeloAgrupado(diagramaAgrupado);
                planService.saveAndFlush(plan);
            }
        }
    }

    private boolean enviarNotificacion(Notificacion notificacion, List<String> playerIds) {
        NotificationManager manager = new NotificationManager();
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Basic MTYzNDAxNzEtZTIwYi00NDY5LTk4NDgtZjJkNzAyZTJjMzE4");
        Map<String, Object> body = new HashMap<>();
        body.put("app_id", "a3ca4ae3-ba22-4004-a14f-7bfe95af0f3e");
        body.put("included_segments", new String[]{"All"});
        Map<String, String> data = new HashMap<>();
        data.put("elementos", "Nueva notificacion.");
        body.put("data", data);
        Map<String, String> contents = new HashMap<>();
        contents.put("es", notificacion.getDescription());
        contents.put("en", notificacion.getDescription());
        body.put("contents", contents);
        Map<String, String> headings = new HashMap<>();
        headings.put("es", notificacion.getTitle());
        headings.put("en", notificacion.getTitle());
        body.put("headings", headings);
        try {
            HashMap<String, Object> hashMap = manager.postForObject("https://onesignal.com/api/v1/notifications", body, HashMap.class, headers);
            for (Map.Entry<String, Object> entry : hashMap.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();
                System.out.println(key);
                System.out.println(value);
                System.out.println();
            }
        } catch (Exception e) {
            LOGGER.warn(e.getLocalizedMessage(), e);
            return false;
        }
        return true;
    }

    @PreAuthorize(value = "isFullyAuthenticated()")
    @RequestMapping(value = "/detallesTarea/{tareaId}", method = {RequestMethod.POST})
    @ApiOperation(value = "Returns the Task instance associated with the given id.")
    public ModelAndView cargarDatos(@PathVariable("tareaId") PlTask plTask, ModelMap map) {
        Management management = plTask.getPosition().getArea().getManagement();
        Plan plan = plTask.getPlan();
        List<ChildTask> childTaskSucesoras = childTaskService.findByFromAndIsChild(plTask.getId(), true);
        antecesoras = new HashSet<>();
        sucesoras = new HashSet<>();
        List<ChildTask> childTasksAntecesoras = childTaskService.findByToAndIsChild(plTask.getId(), true);
        childTaskSucesoras.forEach((ChildTask hijo) -> {
            sucesoras.add(new Antecesora(planTareaService.findOne(hijo.getTo())));
        });
        for (ChildTask childTask : childTasksAntecesoras) {
            Antecesora antecesora = new Antecesora(planTareaService.findOne(childTask.getFrom()));
            if (!existeAntecesora(antecesora)) {
                antecesoras.add(antecesora);
            }
        }
        map.put("antecesoras", antecesoras);
        map.put("sucesoras", sucesoras);
        String diagrama = plan.getDiagrama();
        if (diagrama != null && !diagrama.isEmpty()) {
            Modelo modelo = mapeadorObjetos.readValue(diagrama, Modelo.class);
            if (modelo != null) {
                Node node = modelo.buscarSider("sd" + management.getId());
                if (node == null) {
                    node = new Node();
                    node.setNombre(management.getName());
                    node.setCategory("Row Sider");
                    node.setPeso(management.getOrder());
                    node.setRow(management.getOrder());
                    modelo.addNode(node);
                    plan.setDiagrama(mapeadorObjetos.writeValueAsString(modelo));
                    planService.saveAndFlush(plan);
                }
            }
        }
        List<Area> areas = areaService.findByManagementId(management.getId());
        List<Position> positions = positionService.findByAreaId(plTask.getPosition().getArea().getId());
        List<Document> documents = documentService.findByTaskId(plTask.getId());
        map.put("success", true);
        map.put("tarea", ArregloCreator.cargarTarea(plTask, areas, positions, documents));
        LOGGER.debug("Task details with id: {}", plTask);
        return new RestModelAndView(map);
    }

    private ModelMap tareasPlan(List<PlTask> tasks) {
        ModelMap map = new ModelMap();
        map.put("sEcho", "1");
        map.put("iTotalRecords", tasks.size());
        map.put("iTotalDisplayRecords", tasks.size());
        ModelMap[] modelMaps = new ModelMap[tasks.size()];
        int cont = tasks.size();
        for (int i = 0; i < cont; i++) {
            modelMaps[i] = ArregloCreator.crearTareaPlan(tasks.get(i));
        }
        map.put("aaData", modelMaps);
        return map;
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Error> tratarExcepcion(Exception e) {
        LOGGER.warn(e.getLocalizedMessage(), e);
        OracleException oe = new PlTaskException(e);
        return ResponseEntity.ok(oe.getError());
    }
}
